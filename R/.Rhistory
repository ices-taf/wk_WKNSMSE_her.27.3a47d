'var' = c('Ctransfer','Duptake','Dsplit','Buptake')))
TAC_var[,'Ctransfer'] <- Ctransfer
TAC_var[,'Duptake']   <- Duptake
TAC_var[,'Dsplit']    <- Dsplit
TAC_var[,'Buptake']   <- Buptake
#------------------------------------------------------------------------------#
# 4) run stf to get TAC in 2019. This is because the MP is different than what
# was calculated during HAWG2018
#
# This is used to update stocks which is the bio object.
#
# Note: the recruitment is inferred from SAM. This needs to be changed with a
# stock recruitment relationship.
#------------------------------------------------------------------------------#
# create stf object and calculate stock in ImY
stf <- stf_ImY( NSH.sim,
stocks,
fisheryFuture,
TAC,
TAC_var,
FCPropIts,
c('2018','2019','2020'))
iYr<-'2018'
for(idxIter in 1:nits){
resiCatch <- rnorm( length(varCatchMat[,2,idxIter]),
(1:length(varCatchMat[,2,idxIter]))*0,
varCatchMat[,2,idxIter]) # residual to add to the catch
# catches = landings + deviation
stocks[[idxIter]]@catch.n[,iYr]  <- rowSums(stf@catch.n[,iYr,,,,idxIter])*exp(resiCatch)
stocks[[idxIter]]@catch.wt[,iYr] <- apply(drop(fisheryFuture[,iYr,,'catch.wt',,1]),1,mean)
stocks[[idxIter]]@catch          <- computeCatch(stocks[[idxIter]])
#stocks[[idxIter]]@catch[,iYr]    <- sum(stocks[[idxIter]]@catch.n[,iYr]*
#                                        apply(drop(fisheryFuture[,iYr,,'catch.wt',,1]),1,mean))
#stocks[[idxIter]]@catch[,iYr]    <- sum( rowSums(stf@catch.n[,iYr,,,,idxIter]* # catch.n per fleet
#                                                      stf[,iYr,,,,idxIter]@catch.wt)* # catch.wt per fleet
#                                              exp(resiCatch)) # sum catches accross fleets
#stocks[[idxIter]]@catch.wt[,iYr] <- stocks[[idxIter]]@catch.n[,iYr]/stocks[[idxIter]]@catch[,iYr]
#stocks[[idxIter]]@catch.wt[,iYr] <- apply(drop(fisheryFuture[,iYr,,'catch.wt',,1]),1,mean) # weight at age as mean accross the fleets
stocks[[idxIter]]@landings.n[,iYr]        <- rowSums(stf@catch.n[,iYr,,,,idxIter])
stocks[[idxIter]]@landings.wt[,iYr]       <- apply(drop(fisheryFuture[,iYr,,'catch.wt',,1]),1,mean)
stocks[[idxIter]]@catch                   <- computeLandings(stocks[[idxIter]])
stocks[[idxIter]]@stock.n[,iYr]           <- stf@stock.n[,iYr,1,,,idxIter]
stocks[[idxIter]]@harvest[,iYr]           <- rowSums(stf@harvest[,iYr,,,,idxIter])
surveyNames <- unique(rownames(qMat)) # get all the survey names
for(idxSurvey in 1:length(surveyNames)){
qSelect     <- subset(qMat[,,idxIter],rownames(qMat) == surveyNames[idxSurvey])
varSurv     <- subset(varSurvMat[,,idxIter],rownames(varSurvMat) == surveyNames[idxSurvey])
resiSurv <- rnorm(  length(varSurv[,2]),
(1:length(varSurv[,2]))*0,
varSurv[,2]) # residual to add to the catch
# select number of age for the corresponding ages to the survey
NSelect     <- stocks[[idxIter]]@stock.n[match(as.character(qSelect[,1]),rownames(stocks[[idxIter]]@stock.n)), # filter ages
iYr]  # current year
NSelect     <- drop(NSelect) # drop dimensions with 1 level
FSelect     <-  stocks[[idxIter]]@harvest[match(as.character(qSelect[,1]),rownames(stocks[[idxIter]]@harvest)), # filter ages for F
iYr] # filter year
FSelect     <- drop(FSelect) # drop dimensions with 1 level
Z           <-  stocks[[idxIter]]@m[match(as.character(qSelect[,1]),rownames(stocks[[idxIter]]@m)), # filter ages for M
iYr]  # filter years for M
Z           <- Z + FSelect
surveyProp  <- mean(c(surveys[[surveyNames[idxSurvey]]]@range[6],surveys[[surveyNames[idxSurvey]]]@range[7]))
# filling survey index for current year
surveys[[surveyNames[idxSurvey]]]@index[,iYr,,,,idxIter] <- qSelect[,2]*exp(-Z*surveyProp)*NSelect*exp(resiSurv)
}
}
plot(stocks[[idxIter]]@m)
plot(stocks[[idxIter]]@m[1,])
?yearMeans
idxIter<-1
NSHM2<- window(  stocks[[idxIter]],
start=an(fullPeriod[1]),
end=an(iYr))
extryrs         <- dimnames(NSHM2@m)$year[which(!dimnames(NSHM2@m)$year %in% yrs)]
dimnames(NSHM2@m)$year
dimnames(NSHM2@m)$year
yrAver          <- 1
for(iYr in dimnames(NSHM2@m)$year){
for(iAge in ages[!ages%in%extrags]){
if(iYr %in% extryrsbw) NSHM2@m[ac(iAge),ac(iYr)] <-
yearMeans(NSHM2@m[ac(iAge),ac((iYr+1):(iYr+yrAver)),],na.rm=T)
if(iYr %in% extryrsfw) NSHM2@m[ac(iAge),ac(iYr)] <-
yearMeans(NSHM2@m[ac(iAge),ac((iYr-1):(iYr-yrAver)),],na.rm=T)
}
}
ages            <- dimnames(NSHM2@m)$age
yrAver          <- 1
for(iYr in dimnames(NSHM2@m)$year){
for(iAge in ages[!ages%in%extrags]){
if(iYr %in% extryrsbw) NSHM2@m[ac(iAge),ac(iYr)] <-
yearMeans(NSHM2@m[ac(iAge),ac((iYr+1):(iYr+yrAver)),],na.rm=T)
if(iYr %in% extryrsfw) NSHM2@m[ac(iAge),ac(iYr)] <-
yearMeans(NSHM2@m[ac(iAge),ac((iYr-1):(iYr-yrAver)),],na.rm=T)
}
}
extrags         <- names(which(apply(M2,1,function(x){all(is.na(x))==T})==T))
ages            <- dimnames(NSHM2@m)$age
yrAver          <- 1
for(iYr in dimnames(NSHM2@m)$year){
for(iAge in ages[!ages%in%extrags]){
NSHM2@m[ac(iAge),ac(iYr)] <-
yearMeans(NSHM2@m[ac(iAge),ac((iYr+1):(iYr+yrAver)),],na.rm=T)
}
}
for(iYr in dimnames(NSHM2@m)$year){
for(iAge in ages){
NSHM2@m[ac(iAge),ac(iYr)] <-
yearMeans(NSHM2@m[ac(iAge),ac((iYr+1):(iYr+yrAver)),],na.rm=T)
}
}
ages            <- dimnames(NSHM2@m)$age
yrAver          <- 1
for(iYr in as.numeric(dimnames(NSHM2@m)$year)){
for(iAge in ages){
NSHM2@m[ac(iAge),ac(iYr)] <-
yearMeans(NSHM2@m[ac(iAge),ac((iYr+1):(iYr+yrAver)),],na.rm=T)
}
}
ages            <- dimnames(NSHM2@m)$age
yrAver          <- 1
for(iYr in as.numeric(dimnames(NSHM2@m)$year)){
for(iAge in ages){
NSHM2@m[ac(iAge),ac(iYr)] <-
yearMeans(NSHM2@m[ac(iAge),ac((iYr-1):(iYr+yrAver)),],na.rm=T)
}
}
iAge
iYr
yearMeans(NSHM2@m[ac(iAge),ac((iYr-1):(iYr+yrAver)),],na.rm=T)
for(iYr in as.numeric(dimnames(NSHM2@m)$year)){
for(iAge in ages){
NSHM2@m[ac(iAge),ac(iYr)] <-
yearMeans(NSHM2@m[ac(iAge),ac((iYr+1):(iYr+yrAver)),],na.rm=T)
}
}
iYr
iAge
for(iYr in (as.numeric(dimnames(NSHM2@m)$year))-1){
for(iAge in ages){
NSHM2@m[ac(iAge),ac(iYr)] <-
yearMeans(NSHM2@m[ac(iAge),ac((iYr+1):(iYr+yrAver)),],na.rm=T)
}
}
years           <- as.numeric(dimnames(NSHM2@m)$year)
years
years           <- years[1:length(years)-1]
years
for(iYr in years){
for(iAge in ages){
NSHM2@m[ac(iAge),ac(iYr)] <-
yearMeans(NSHM2@m[ac(iAge),ac((iYr+1):(iYr+yrAver)),],na.rm=T)
}
}
plot(NSHM2@m)
plot(stocks[[idxIter]]@m)
#-------------------------------------------------------------------------------
# WKNSMSE
#
# Author: Benoit Berges
#         WMR, The Netherland
# email: benoit.berges@wur.nl
#
#  MSE of North Sea Herring
#
# Date: 2018/11/18
#
# Build for R3.5.1, 64bits
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# 1) load packages
#    setup paths
#    load functions
#-------------------------------------------------------------------------------
rm(list=ls())
library(FLSAM)
library(FLEDA)
# define path to directory
#path          <- "D:/Work/Herring MSE/NSAS/"
path              <- "D:/git/wk_WKNSMSE_her.27.3a47d/R/"
#path              <- "F:/WKNSMSE/wk_WKNSMSE_her.27.3a47d/R"
assessment_name   <- "NSAS_WKNSMSE2018"
try(setwd(path),silent=TRUE)
# paths to different subfolders
dataPath      <- file.path(".","data/")
outPath       <- file.path(".","results/")
scriptPath    <- file.path(".","side_scripts/")
functionPath  <- file.path(".","functions/")
# loading function
source(file.path(functionPath,"randBlocks.R"))
source(file.path(functionPath,"randNums.R"))
#-------------------------------------------------------------------------------
# 2) load assessment objects (single and multi fleet)
#    define MSE parameters
#    load raw M
#
# Note 1: the assessments we use is without the LAI index. The assessments that
# are ran during HAWG is using the LAI so results are slightly different. See
# 00_test_no_LAI.R for a comparison of the assessments. This is for convenience
# as the LAI is a component index and is weekly structured, therefore
# complicated to implement
#-------------------------------------------------------------------------------
#- Load single fleet and multi fleet assessment objects - using assessments without the LAI
#load(file.path(outPath,paste0(assessment_name,'_mf.Rdata')))
#load(file.path(outPath,paste0(assessment_name,'_sf.Rdata')))
load(file.path(outPath,paste0(assessment_name,'_mf_noLAI.Rdata')))
load(file.path(outPath,paste0(assessment_name,'_sf_noLAI.Rdata')))
# parameters
n.retro.years       <-  7                                       # Number of years for which to run the retrospective
nFutureyrs          <- 20
histMinYr           <- dims(NSH)$minyear
histMaxYr           <- dims(NSH)$maxyear
yearCurrent         <- histMinYr:histMaxYr # vector the years
futureMaxYr         <- histMaxYr + nFutureyrs
histPeriod          <- ac(histMinYr:histMaxYr)
projPeriod          <- ac((histMaxYr+1):futureMaxYr)
fullPeriod          <- c(histPeriod,projPeriod)
recrPeriod          <- ac(2007:2017)
selPeriod           <- ac(2007:2017)
fecYears            <- ac(2007:2017)
nits                <- 10 # number of random samples
# reading the raw M and applying plus group
raw_M             <- read.csv(file.path(dataPath,"Smoothed_span50_M_NotExtrapolated_NSASSMS2016.csv"),header=TRUE)
colnames(raw_M)   <- sub("X","",colnames(raw_M))
rownames(raw_M)   <- raw_M[,1]
raw_M             <- raw_M[,-1]# Trim off first column as it contains 'ages'
raw_M             <- cbind(replicate(as.numeric(colnames(raw_M)[1])-histMinYr,raw_M[,1]), raw_M)
raw_M             <- cbind(raw_M,raw_M[,dim(raw_M)[2]])
colnames(raw_M)   <- histMinYr:histMaxYr
# hack to set plus group, converting M array into an FLStock object, using the setPlusGroup, then back to array
# !!!!!! to be updated. Right now one uses an empty FLStock object. This is wrong as I think the setting of the plus group
# needs the catches as input
NSHM2             <- readFLStock(file.path(dataPath,"index.txt"),no.discards=TRUE,quiet=FALSE)
NSHM2@m[]         <- as.matrix(raw_M)
pg                <- NSH@range['max']
NSHM2             <- setPlusGroup(NSHM2,pg) # really wonder if the setPlusGroup does anything... Needs clarifying.
raw_M             <- drop(NSHM2@m)
raw_M             <- raw_M + 0.11
plot(raw_M[1,])
dim(raw_M)
?medianFilter
install.packages("signal")
library(signal)
medfilt1(raw_M, n = 5)
dim(raw_M)
a<-medfilt1(raw_M[1,], n = 5)
library(stats)
a<-runmed(raw_M[1,], n = 5)
?runmed
a<-runmed(raw_M[1,], k = 5)
plot(a)
plot(raw_M[1,])
#-------------------------------------------------------------------------------
# WKNSMSE
#
# Author: Benoit Berges
#         WMR, The Netherland
# email: benoit.berges@wur.nl
#
#  MSE of North Sea Herring
#
# Date: 2018/11/18
#
# Build for R3.5.1, 64bits
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# 1) load packages
#    setup paths
#    load functions
#-------------------------------------------------------------------------------
rm(list=ls())
library(FLSAM)
library(FLEDA)
library(minpack.lm)  # install.packages("minpack.lm")
library(stats)
# define path to directory
#path          <- "D:/Work/Herring MSE/NSAS/"
path              <- "D:/git/wk_WKNSMSE_her.27.3a47d/R/"
#path              <- "F:/WKNSMSE/wk_WKNSMSE_her.27.3a47d/R"
assessment_name   <- "NSAS_WKNSMSE2018"
try(setwd(path),silent=TRUE)
# paths to different subfolders
dataPath      <- file.path(".","data/")
outPath       <- file.path(".","results/")
scriptPath    <- file.path(".","side_scripts/")
functionPath  <- file.path(".","functions/")
source(file.path(functionPath,"optF_TACdiff.R"))
source(file.path(functionPath,"stf_ImY.R"))
#-------------------------------------------------------------------------------
# 2) Initialize
#
# Define MSE parameters,
# load objects initialized previously
#   * Biology
#     - stocks
#     - surveys
#   * Fisheries
#     - FCProp
#     - catchD
#     - F sel: FAsel, FCsel, FBDsel
#-------------------------------------------------------------------------------
# load object
load(file.path(outPath,paste0(assessment_name,'_init_MSE.RData')))
# load MSE parameters
load(file.path(outPath,paste0(assessment_name,'_parameters_MSE.RData')))
strFleet  <- c('A','B','C','D')
nFleets   <- length(strFleet)
nAges     <- dim(stocks[[1]])[1]
#-------------------------------------------------------------------------------
# 2) Organize objects
# here, 2 main objects are defined:
#   * biology
#   * fishery object for each fleet
#-------------------------------------------------------------------------------
#------------------------------------------------------------------------------#
# 3) Define TACs for A, B and D fleets.
# TACs for A and B fleets are taken out of HAWG2018. This needs updating
#
# Note 1: The Cfleet is defined as a proportion of F.
# Note 2: TAC for C and D fleets are for the WB
# Note 3: TACs for the D fleet is kept constant for future years
#------------------------------------------------------------------------------#
TAC                                   <- FLQuant(NA,dimnames=list(age='all',
year=histMinYr:(futureMaxYr+3),
unit=c('TAC'),
season='all',
area=c('A','B','C','D'),
iter=1:nits))
# TAC for A fleet in NS
TAC_A                     <- read.table(file.path(dataPath,'TAC_A.csv'),sep = ",")
TAC[,ac(TAC_A[,1]),,,"A"] <- TAC_A[,2]
# TAC for B fleet in NS
TAC_B                     <- read.table(file.path(dataPath,'TAC_B.csv'),sep = ",")
TAC[,ac(TAC_B[,1]),,,"B"] <- TAC_B[,2]
# TAC for D fleet in WB
TAC_D                     <- read.table(file.path(dataPath,'TAC_D.csv'),sep = ",")
TAC[,ac(TAC_D[,1]),,,"D"] <- TAC_D[,2]
TAC[,ac((max(TAC_D[,1])+1):(futureMaxYr+3)),,,"D"] <- TAC[,ac(max(TAC_D[,1])),,,"D"] # TAC is fixed for the D fleet
# TAC for C fleet in WB
TAC_C                     <- read.table(file.path(dataPath,'TAC_C.csv'),sep = ",")
TAC[,ac(TAC_C[,1]),,,"C"] <- TAC_C[,2]
# fixed TAC C in WB (used for transfer to the A fleet)
TAC[,ac((max(TAC_C[,1])+1):(futureMaxYr+3)),,,"C"] <- TAC_C[dim(TAC_C)[1],2]
# randomize TAC C in WB (used for transfer to the A fleet)
#TAC[,ac((max(TAC_C[,1])+1):(futureMaxYr+3)),,,"C"] <- rnorm(length((max(TAC_C[,1])+1):(futureMaxYr+3)),
#                                                            mean(TAC_C[,2]),
#                                                           sd(TAC_C[,2])) # set random TAC for the C fleet in WB
# setup variables for transfer, uptake and split
uptakeFleets <- read.table(file.path(dataPath,'over_underfishing2017.csv'),sep = ",")
# need to input the split for the D fleet - ask Henrik
# transfer from C fleet TAC to fleet A
Ctransfer   <- runif(length(projPeriod),min=0.4, max=0.5)    # Transfer of TAC from IIIa to IVa for C fleet in assessment year. Set between 0.4 and 0.5
# update for the D fleeta
Duptake     <- rep(1, length(projPeriod)) # assume full uptake for the D fleet
Dsplit      <- rep(0.60, length(projPeriod)) # NSAS/WBSS split randomization based on historical records. Fixed for now, need to contact henrik
# update for the B fleet
Buptake     <- rnorm (length(projPeriod),
mean(an(as.vector(uptakeFleets[2:16,3])),na.rm=TRUE), # mean over available historical values
sd(an(as.vector(uptakeFleets[2:16,3])),na.rm=TRUE))   # sd over available historical values
TAC_var     <- array(NA,
dim=c(length(projPeriod),
4),
dimnames=list('years' = projPeriod,
'var' = c('Ctransfer','Duptake','Dsplit','Buptake')))
TAC_var[,'Ctransfer'] <- Ctransfer
TAC_var[,'Duptake']   <- Duptake
TAC_var[,'Dsplit']    <- Dsplit
TAC_var[,'Buptake']   <- Buptake
#------------------------------------------------------------------------------#
# 4) run stf to get TAC in 2019. This is because the MP is different than what
# was calculated during HAWG2018
#
# This is used to update stocks which is the bio object.
#
# Note: the recruitment is inferred from SAM. This needs to be changed with a
# stock recruitment relationship.
#------------------------------------------------------------------------------#
# create stf object and calculate stock in ImY
stf <- stf_ImY( NSH.sim,
stocks,
fisheryFuture,
TAC,
TAC_var,
FCPropIts,
c('2018','2019','2020'))
#-------------------------------------------------------------------------------
# WKNSMSE
#
# Author: Benoit Berges
#         WMR, The Netherland
# email: benoit.berges@wur.nl
#
#  MSE of North Sea Herring
#
# Date: 2018/11/18
#
# Build for R3.5.1, 64bits
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# 1) load packages
#    setup paths
#    load functions
#-------------------------------------------------------------------------------
rm(list=ls())
library(FLSAM)
library(FLEDA)
library(minpack.lm)  # install.packages("minpack.lm")
library(stats)
# define path to directory
#path          <- "D:/Work/Herring MSE/NSAS/"
path              <- "D:/git/wk_WKNSMSE_her.27.3a47d/R/"
#path              <- "F:/WKNSMSE/wk_WKNSMSE_her.27.3a47d/R"
assessment_name   <- "NSAS_WKNSMSE2018"
try(setwd(path),silent=TRUE)
# paths to different subfolders
dataPath      <- file.path(".","data/")
outPath       <- file.path(".","results/")
scriptPath    <- file.path(".","side_scripts/")
functionPath  <- file.path(".","functions/")
source(file.path(functionPath,"optF_TACdiff.R"))
source(file.path(functionPath,"stf_ImY.R"))
#-------------------------------------------------------------------------------
# 2) Initialize
#
# Define MSE parameters,
# load objects initialized previously
#   * Biology
#     - stocks
#     - surveys
#   * Fisheries
#     - FCProp
#     - catchD
#     - F sel: FAsel, FCsel, FBDsel
#-------------------------------------------------------------------------------
# load object
load(file.path(outPath,paste0(assessment_name,'_init_MSE.RData')))
# load MSE parameters
load(file.path(outPath,paste0(assessment_name,'_parameters_MSE.RData')))
strFleet  <- c('A','B','C','D')
nFleets   <- length(strFleet)
nAges     <- dim(stocks[[1]])[1]
TAC                                   <- FLQuant(NA,dimnames=list(age='all',
year=histMinYr:(futureMaxYr+3),
unit=c('TAC'),
season='all',
area=c('A','B','C','D'),
iter=1:nits))
# TAC for A fleet in NS
TAC_A                     <- read.table(file.path(dataPath,'TAC_A.csv'),sep = ",")
TAC[,ac(TAC_A[,1]),,,"A"] <- TAC_A[,2]
# TAC for B fleet in NS
TAC_B                     <- read.table(file.path(dataPath,'TAC_B.csv'),sep = ",")
TAC[,ac(TAC_B[,1]),,,"B"] <- TAC_B[,2]
# TAC for D fleet in WB
TAC_D                     <- read.table(file.path(dataPath,'TAC_D.csv'),sep = ",")
TAC[,ac(TAC_D[,1]),,,"D"] <- TAC_D[,2]
TAC[,ac((max(TAC_D[,1])+1):(futureMaxYr+3)),,,"D"] <- TAC[,ac(max(TAC_D[,1])),,,"D"] # TAC is fixed for the D fleet
# TAC for C fleet in WB
TAC_C                     <- read.table(file.path(dataPath,'TAC_C.csv'),sep = ",")
TAC[,ac(TAC_C[,1]),,,"C"] <- TAC_C[,2]
# fixed TAC C in WB (used for transfer to the A fleet)
TAC[,ac((max(TAC_C[,1])+1):(futureMaxYr+3)),,,"C"] <- TAC_C[dim(TAC_C)[1],2]
# randomize TAC C in WB (used for transfer to the A fleet)
#TAC[,ac((max(TAC_C[,1])+1):(futureMaxYr+3)),,,"C"] <- rnorm(length((max(TAC_C[,1])+1):(futureMaxYr+3)),
#                                                            mean(TAC_C[,2]),
#                                                           sd(TAC_C[,2])) # set random TAC for the C fleet in WB
# setup variables for transfer, uptake and split
uptakeFleets <- read.table(file.path(dataPath,'over_underfishing2017.csv'),sep = ",")
# need to input the split for the D fleet - ask Henrik
# transfer from C fleet TAC to fleet A
Ctransfer   <- runif(length(projPeriod),min=0.4, max=0.5)    # Transfer of TAC from IIIa to IVa for C fleet in assessment year. Set between 0.4 and 0.5
# update for the D fleeta
Duptake     <- rep(1, length(projPeriod)) # assume full uptake for the D fleet
Dsplit      <- rep(0.60, length(projPeriod)) # NSAS/WBSS split randomization based on historical records. Fixed for now, need to contact henrik
# update for the B fleet
Buptake     <- rnorm (length(projPeriod),
mean(an(as.vector(uptakeFleets[2:16,3])),na.rm=TRUE), # mean over available historical values
sd(an(as.vector(uptakeFleets[2:16,3])),na.rm=TRUE))   # sd over available historical values
TAC                                   <- FLQuant(NA,dimnames=list(age='all',
year=histMinYr:(futureMaxYr+3),
unit=c('TAC'),
season='all',
area=c('A','B','C','D'),
iter=1:nits))
# TAC for A fleet in NS
TAC_A                     <- read.table(file.path(dataPath,'TAC_A.csv'),sep = ",")
TAC[,ac(TAC_A[,1]),,,"A"] <- TAC_A[,2]
# TAC for B fleet in NS
TAC_B                     <- read.table(file.path(dataPath,'TAC_B.csv'),sep = ",")
TAC[,ac(TAC_B[,1]),,,"B"] <- TAC_B[,2]
# TAC for D fleet in WB
TAC_D                     <- read.table(file.path(dataPath,'TAC_D.csv'),sep = ",")
TAC[,ac(TAC_D[,1]),,,"D"] <- TAC_D[,2]
TAC[,ac((max(TAC_D[,1])+1):(futureMaxYr+3)),,,"D"] <- TAC[,ac(max(TAC_D[,1])),,,"D"] # TAC is fixed for the D fleet
# TAC for C fleet in WB
TAC_C                     <- read.table(file.path(dataPath,'TAC_C.csv'),sep = ",")
TAC[,ac(TAC_C[,1]),,,"C"] <- TAC_C[,2]
# fixed TAC C in WB (used for transfer to the A fleet)
TAC[,ac((max(TAC_C[,1])+1):(futureMaxYr+3)),,,"C"] <- TAC_C[dim(TAC_C)[1],2]
uptakeFleets <- read.table(file.path(dataPath,'over_underfishing2017.csv'),sep = ",")
Ctransfer   <- runif(length(projPeriod),min=0.4, max=0.5)    # Transfer of TAC from IIIa to IVa for C fleet in assessment year. Set between 0.4 and 0.5
# update for the D fleeta
Duptake     <- rep(1, length(projPeriod)) # assume full uptake for the D fleet
Dsplit      <- rep(0.60, length(projPeriod)) # NSAS/WBSS split randomization based on historical records. Fixed for now, need to contact henrik
# update for the B fleet
Buptake     <- rnorm (length(projPeriod),
mean(an(as.vector(uptakeFleets[2:16,3])),na.rm=TRUE), # mean over available historical values
sd(an(as.vector(uptakeFleets[2:16,3])),na.rm=TRUE))   # sd over available historical values
?rnorm
mean(an(as.vector(uptakeFleets[2:16,3])),na.rm=TRUE)
?mean
an(as.vector(uptakeFleets[2:16,3]))
uptakeFleets[2:16,3]
as.vector(uptakeFleets[2:16,3])
